\documentclass[10pt, a4paper]{article}
%\usepackage[utf8]{inputenc}
% especifico márgenes manualmente
\usepackage[paper=a4paper]{geometry}
% codificación ISO-8859-1
%\usepackage[latin1]{inputenc}
% separación silábica en castellano
\usepackage[spanish]{babel}
%\usepackage{framed}
%\usepackage{array}
%\usepackage{tabular}

\title{Trabajo Pr\'actico 1}
\author{Eric Brandwein}
\date{Abril 2018}

\begin{document}

\maketitle

% compilar 2 veces para actualizar las referencias
\tableofcontents

\pagebreak
%\newpage


\section{Descripci\'on del problema}

%\begin{framed}
El problema a resolver en este informe será el ya conocido problema de la mochila, o "Knapsack problem", en inglés. Su enunciado dice así: \\
Dado un conjunto de $n$ ítems $S$, cada uno con un tamaño asociado $w_i$ y un beneficio asociado $p_i$, y una mochiula con una capacidad asociada $W$, encontrar el subconjunto de ítems de $S$ que maximice el beneficio total sin exceder la capacidad de la mochila. Es decir, encontrar $R \subseteq S$ tal que $\sum_{i \in R} p_i$ sea máxima y se cumpla $\sum_{i \in R} w_i \leq W$. Asumiremos que todos los valores mencionados son enteros no negativos.\par

Para entender mejor el problema, mostraremos un ejemplo: \par
Imaginemos que poseemos una mochila con capacidad 25, y quye poseemos 5 ítems, cada uno con su tamaño y beneficio asociados de esta forma:
\begin{tabular}{c|c|c}
	ítem & tamaño & beneficio \\ \hline
	1 & 10 & 5 \\
	2 & 15 & 4 \\
	3 & 5 & 13 \\
	4 & 10 & 8 \\
	5 & 5 & 8
\end{tabular}
La combinación de ítems que maximizará el beneficio sin pasarse de la capacidad de la mochila será el conjunto $\{3, 4, 5\}$, que juntos suman un tamaño de $5 + 10 + 5 = 20$ y un beneficio de $13 + 8 + 8 = 29$. Cualquier otra combinación de los ítems que poseemos o no entrará en la mochila por tener un tamaño total mayor a la capacidad, o tendrá un beneficio total menor o igual al beneficio alcanzado con la solución dada. \par

Algorítmicamente, desarrollaremos cuatro maneras de llegar a la solución para cualquier conjunto de argumentos. Demostraremos la correctitud de cada una, y luego las compararemos tanto en términos de complejidad teórica como con comprobaciones empíricas. Las estrategias de programación que utilizaremos son:
\begin{itemize}
	\item Fuerza Bruta
	\item Backtracking
	\item Meet in the Middle
	\item Programación Dinámica
\end{itemize}

\section{Fuerza Bruta}
Este algoritmo resuelve el problema comparando todas las combinaciones de ítems entre sí.
Las mismas se generan una tras otra. Cada vez que se genera una combinación de ítems, se calcula su beneficio y su tamaño total. Si el tamaño es mayor a la capacidad de la mochila, la combinación se descarta. Si no, se compara el beneficio total de la solución actual con el mayor beneficio alcanzado hasta el momento, y se mantiene el mayor beneficio entre los dos, para ser comparado más tarde con la próxima posible solución. Si para el momento de la comparación no se había encontrado todavía una combinación que "entrase" en la mochila, el mayor beneficio encontrado hasta el momento será igual a cero. Podemos comenzar asumiendo un beneficio cero porque sabemos que siempre existe por lo menos una combinación de ítems con este beneficio; particularmente, la combinación en la que no se pone ningún item en la mochila posee este beneficio total.\par
En el momento en el que ya se hubieron recorrido todas las combinaciones, el resultado será el mayor beneficio encontrado. \par

Sabemos que no hay un mejor resultado que el devuelto porque si existiese una combinación con beneficio mayor, la hubiésemos encontrado y guardado. Y sabemos que hay una combinación con ese beneficio porque solo guardamos el resultado si encontramos una combinación con ese valor. Por ende, el resultado devuelto es el correcto.



%\end{framed}
\end{document}
