\documentclass[10pt, a4paper]{article}
\usepackage[utf8]{inputenc}
% especifico márgenes manualmente
\usepackage[paper=a4paper]{geometry}
% codificación ISO-8859-1
%\usepackage[latin1]{inputenc}
% separación silábica en castellano
\usepackage[spanish]{babel}
\usepackage{algorithm}
\usepackage{algpseudocode}
%\usepackage{framed}
%\usepackage{array}
%\usepackage{tabular}

\title{Trabajo Pr\'actico 1}
\author{Eric Brandwein}
\date{Abril 2018}

\begin{document}

\maketitle

% compilar 2 veces para actualizar las referencias
\tableofcontents

\pagebreak
%\newpage


\section{Descripci\'on del problema}

%\begin{framed}
El problema a resolver en este informe será el ya conocido problema de la mochila, o "Knapsack problem", en inglés. Su enunciado dice así: \\
Dado un conjunto de $n$ ítems $S$, cada uno con un tamaño asociado $w_i$ y un beneficio asociado $p_i$, y una mochiula con una capacidad asociada $W$, encontrar el subconjunto de ítems de $S$ que maximice el beneficio total sin exceder la capacidad de la mochila. Es decir, encontrar $R \subseteq S$ tal que $\sum_{i \in R} p_i$ sea máxima y se cumpla $\sum_{i \in R} w_i \leq W$. Asumiremos que todos los valores mencionados son enteros no negativos.\par

Para entender mejor el problema, mostraremos un ejemplo: \par
Imaginemos que poseemos una mochila con capacidad 25, y que poseemos 5 ítems, cada uno con su tamaño y beneficio asociados de esta forma: \\
\begin{tabular}{c|c|c}
	ítem & tamaño & beneficio \\ \hline
	1 & 10 & 5 \\
	2 & 15 & 4 \\
	3 & 5 & 13 \\
	4 & 10 & 8 \\
	5 & 5 & 8
\end{tabular} \\
La combinación de ítems que maximizará el beneficio sin pasarse de la capacidad de la mochila será el conjunto $\{3, 4, 5\}$, que juntos suman un tamaño de $5 + 10 + 5 = 20$ y un beneficio de $13 + 8 + 8 = 29$. Cualquier otra combinación de los ítems que poseemos o no entrará en la mochila por tener un tamaño total mayor a la capacidad, o tendrá un beneficio total menor o igual al beneficio alcanzado con la solución dada. \par

Algorítmicamente, desarrollaremos cuatro maneras de llegar a la solución para cualquier conjunto de argumentos. Demostraremos la correctitud de cada una, y luego las compararemos tanto en términos de complejidad teórica como con comprobaciones empíricas. Las estrategias de programación que utilizaremos son:
\begin{itemize}
	\item Fuerza Bruta
	\item Meet in the Middle
	\item Backtracking
	\item Programación Dinámica
\end{itemize}

\section{Fuerza Bruta}
\subsection{Descripción}
Este algoritmo resuelve el problema comparando todas las combinaciones de ítems entre sí.
Las mismas se generan una tras otra. Cada vez que se genera una combinación de ítems, se calcula su beneficio y su tamaño total. Si el tamaño es mayor a la capacidad de la mochila, la combinación se descarta. Si no, se compara el beneficio total de la solución actual con el mayor beneficio alcanzado hasta el momento, y se mantiene el mayor beneficio entre los dos, para ser comparado más tarde con la próxima posible solución. Si para el momento de la comparación no se había encontrado todavía una combinación que entrase en la mochila, el mayor beneficio encontrado hasta el momento será igual a cero. Podemos comenzar asumiendo un beneficio cero porque sabemos que siempre existe por lo menos una combinación de ítems con este beneficio; particularmente, la combinación en la que no se pone ningún item en la mochila posee este beneficio total.\par
En el momento en el que ya se hubieron recorrido todas las combinaciones, el resultado será el mayor beneficio encontrado. \par

\subsection{Pseudocódigo}
\begin{algorithm}
\caption{Fuerza Bruta}
\begin{algorithmic}[1]
\Function{fuerzaBruta}{$capacidad, items$}
	\State $mayorBeneficio \gets 0$
	\State $combinacionActual \gets $\Call{primerCombinacion}{items}
	\While{\Call{combinacionValida?}{combinacionActual}}
		\State $tamanioActual \gets $\Call{tamanioDeCombinacion}{combinacion}
		\If{$tamanioActual \leq capacidad$}
			\State $beneficioActual \gets $\Call{beneficioDeCombinacion}{combinacionActual}
			\State $mayorBeneficio \gets max(beneficioActual, mayorBeneficio)$
		\EndIf

		\State $combinacionActual \gets $\Call{proximaCombinacion}{combinacionActual}
	\EndWhile
	\State \Return $mayorBeneficio$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Correctitud}
Sabemos que no hay un mejor resultado que el devuelto porque si existiese una combinación con beneficio mayor, la hubiésemos encontrado y guardado. Y sabemos que hay una combinación con ese beneficio porque solo guardamos el resultado si encontramos una combinación con ese beneficio. Por ende, el resultado devuelto es el correcto. \par

\subsection{Complejidad}
Para calcular la complejidad, seguiremos el pseudocódigo anterior paso a paso. Tomaremos $n$ como la cantidad de ítems que se pasan como parámetro.\par
\begin{itemize}
	\item Las líneas 2 y 12 tienen una complejidad de $O(1)$.
	\item La línea 3 llama a la función $primerCombinacion$, que devuelve una combinación de ítems en $O(n)$.
	\item En la línea 4 comienza el bucle que recorrerá todas las combinaciones de ítems. La cantidad de combinaciones de ítems será $2^n$, ya que cada por cada ítem hay dos posibilidades: que esté adentro de la mochila o que no esté. Además, en la misma linea se llama a la función $combinacionValida?$, la cual tiene una complejidad de $O(n)$. Así que, en un principio, este bucle tiene una complejidad de $O(2^n * n)$.
	\item La línea 5 llama a $tamanioDeCombinacion$, que calcula la suma de todos los tamaños de cada ítem presente en la combinación actual. Tiene una complejidad de $O(n)$, la cual no suma a la complejidad ya establecida del bucle de $O(2^n * n)$.
	\item La línea 6 realiza una comparación simple, de complejidad $O(1)$. Lo mismo sucede con la línea 8, que solo calcula un máximo.
	\item La línea 7 hace algo parecido a la línea 5, pero en vez de sumar los tamaños, suma los beneficios. Otra vez, no aumenta la complejidad ya establecida para el bucle.
	\item La línea 10 calcula la próxima combinación de ítems. Esto se puede lograr con una complejidad de $O(n)$, si tomamos una combinación de items como un número binario de longitud $n$, con los $1$ significando que el ítem está presente. La primera combinación podría ser la vacía, y cada vez que se avanza a la siguiente combinación, lo único que se hace es sumarle uno al número binario que representaba a la combinación anterior. Esta línea tampoco aumenta la complejidad del bucle.
\end{itemize}
Gracias a éste análisis, podemos ahora sumar las complejidades de cada línea, y encontrar la complejidad final del algoritmo: $2 * O(1) + O(n) + O(2^n * 3n) = O(2^n * n)$.


\section{Meet in the Middle}
\subsection{Descripción}
Este algoritmo toma ventaja de la búsqueda binaria para mejorar la complejidad del algoritmo de fuerza bruta. A grandes rasgos, el algoritmo sigue estos pasos: \\
\begin{enumerate}
	\item Divide al conjunto de ítems en dos mitades;
	\item Encuentra los tamaños y beneficios del conjunto de partes de cada una, sacando las partes que tengan un tamaño mayor a la capacidad de la mochila;
	\item Ordena las partes de la segunda mitad de menor a mayor en tamaño, y si hay dos partes con el mismo tamaño, las ordena de mayor a menor en beneficio;
	\item Saca las partes de la segunda mitad para las que exista otra parte con menor o igual tamaño e igual o mayor beneficio;
	\item Por cada parte del primer conjunto, se encuentra, con una búsqueda binaria por tamaño en el segundo conjunto, la parte que mejor llene la restante capacidad de la mochila. Es decir, la parte del segundo conjunto que tenga el mayor tamaño de las partes que, sumando el tamaño de la parte del primer conjunto, no sobrepasen la capacidad de la mochila;
	\item Se suman los beneficios de la parte encontrada con la parte actual del primer conjunto;
	\item Se encuentra el mayor beneficio entre las partes restantes, y se llega al resultado deseado.
\end{enumerate}


\subsection{Pseudocódigo}
\begin{algorithm}
\caption{Meet in the Middle}
\begin{algorithmic}[1]
\Function{meetInTheMiddle}{$capacidad, items$}
	\State $primerMitad \gets items[0..items.size / 2]$
	\State $segundaMitad \gets items[items.size / 2..items.size]$

	\State $primerasPartes \gets $ \Call{conjuntoDePartes}{$primerMitad, capacidad$}
	\State $segundasPartes \gets $ \Call{conjuntoDePartes}{$segundaMitad, capacidad$}

	\State $segundasPartes \gets $ \Call{ordenarPartes}{$segundasPartes$}
	\State $segundasPartes \gets $ \Call{sacarInservibles}{$segundasPartes$}

	\State $posiblesSoluciones \gets $ \Call{combinar}{$primerasPartes, segundasPartes, capacidad$}

	\State $mayorBeneficio \gets $ \Call{encontrarMayorBeneficio}{$posiblesSoluciones$}
	\State \Return $mayorBeneficio$
\EndFunction
\\
\Function{conjuntoDePartes}{$items, capacidad$}
	\State $partes \gets \{parte(beneficio=0, tamano=0)\}$
	\ForAll{$items$}
		\ForAll{$partes$}
			\State $nuevaParte \gets parteActual + itemActual$
			\If{$nuevaParte.tamano <= capacidad$}
				\State $partes.pushBack(nuevaParte)$
			\EndIf
		\EndFor
	\EndFor
	\State \Return $partes$
\EndFunction
\\
\Function{sacarInservibles}{$partesOriginales$}

	\State $partes \gets \{parte(beneficio=0, tamano=0)\}$
	\ForAll{partesOriginales}
		\State $parteAnterior \gets partes.back()$
		\If{$parteAnterior.beneficio < parteActual.beneficio$}
			\State $partes.pushBack(parteActual)$
		\EndIf
	\EndFor

	\State \Return $partes$
\EndFunction
\\
\Function{combinar}{$primerasPartes, segundasPartes, capacidad$}
	\State $partesCombinadas \gets \{\}$
	\ForAll{$primerasPartes$}
		\State $parteResultante \gets parteActual$
		\State $tamanoRestante \gets capacidad - parteActual.tamano$
		\State $segundaParteComplementaria \gets$\Call{buscarParteConTamano}{$segundasPartes, tamanoRestante$}
		\If{$segundaParteComplementaria != null$}
			\State $parteResultante \gets parteResultante + segundaParteComplementaria$
		\EndIf
		\State $partesCombinadas.pushBack(parteResultante)$
	\EndFor
	\State \Return $partesCombinadas$
\EndFunction
\end{algorithmic}
\end{algorithm}
\pagebreak
\subsection{Correctitud}
%Sabemos que por lo menos uno de los conjuntos de ítems es la solución, porque sabemos que siempre por lo menos el conjunto vacío entra en la mochila.
%Demostraremos la correctitud siguiendo los pasos de la descripción.
Veamos que el valor devuelto es en realidad la solución del problema. \par
Al principio, encontramos el conjunto de partes de cada una de las dos mitades, con un bucle que recorre todos los items. Por cada item, se suma su tamaño y su beneficio a todas las partes que ya se habían creado, y se generan partes nuevas. Así, tenemos todas las partes que se pueden armar con todos los items anteriores, más todas las mismas pero con el nuevo ítem. Cuando terminamos de recorrer todos los ítems, obtenemos todas las partes posibles de esa mitad, excepto las que sobrepasan la capacidad de la mochila, las cuales removemos.\par
Luego, ordenamos las partes de menor a mayor en tamaño, y si dos combinaciones tienen el mismo tamaño, ordenamos de mayor a menor en beneficio. Hacer esto nos simplifica la tarea de remover las partes que llamamos ``inservibles". Son las partes para las cuales existe una parte en la misma mitad que sea mejor, es decir, que tenga menor o igual tamaño y mayor o igual beneficio. Si existe tal parte, la misma aprovecha mejor o igual el mismo tamaño, y por lo tanto no es necesario conservar las que lo utilizan peor. En el caso especial en la que hay dos combinaciones con el mismo beneficio y el mismo tamaño, se puede conservar cualquiera de las dos, por ejemplo, la que aparezca primero cuando recorremos el conjunto.\par
Para ver cómo nos simplifica la filtración del arreglo de partes el haberlas ordenado de esta forma, imaginemos que, por cada combinación, partimos el arreglo en dos: el arreglo de las combinaciones posteriores, y el de las anteriores. Asumamos que ya habíamos filtrado el arreglo anterior a esta combinación. Este arreglo total estaba ordenado por tamaño, así que el último elemento será el de mayor tamaño, pero tendrá menor o igual tamaño que la combinación actual. También será el de mayor beneficio, porque si hubiese uno de mayor beneficio con menor peso, este sería inservible. Ahora, por cómo habíamos ordenado el arreglo, las combinaciones posteriores a la actual o tienen mayor tamaño, o tienen igual tamaño pero menor o igual beneficio. Esto quiere decir que ninguna hará que esta sea inservible. Llegamos a la conclusión de que solamente las combinaciones anteriores pueden ser mejores. Y, como la última combinación de la mitad anterior tiene mayor beneficio que todas las otras, y menor o igual peso que la combinación actual, solo hace falta comparar con ella el beneficio de la combinación actual para llegar a la decisión de si es inservible o no. Como esto ocurre con cada una de las combinaciones, no nos hace falta hacer más de una comparación por combinación del conjunto.\par
Sacar los inservibles hace que no pueda haber dos combinaciones con el mismo tamaño en la segunda mitad. Esto se debe a que, si hubiese dos con el mismo tamaño, alguna tendría menor o igual beneficio que la otra, y por lo tanto la habríamos sacado. Además, esa mitad está ordenada por beneficio, ya que si hubiese uno posterior a otro con mayor beneficio, el anterior tendría menor tamaño, lo que haría que este sea inservible.\par
Ahora queremos combinar las combinaciones de los conjuntos para llegar a posibles soluciones. Por cada combinación en el primer conjunto, encontramos, con una búsqueda binaria, la que tenga mayor tamaño en la segunda mitad sin pasarse de la capacidad total si sumamos los tamaños. Sabemos que la misma será la que mayor beneficio nos pueda aportar para la combinación actual, por el hecho de que el arreglo está ordenado por tamaño y por beneficio. Así, obtenemos la mejor combinación total de ítems para cada semi-combinación de ítems de la primer mitad\par
Tenemos ahora las mejores combinaciones de ítems totales, y para resolver el problema encontramos la que tenga mayor beneficio de todas, y devolvemos su valor.

\subsection{Complejidad}
Para llegar a una cota de la complejidad de este algoritmo, analizaremos cada función que utililza, y luego las uniremos.\par
Comenzando, en el pseudocódigo mostrado, por la función $conjuntoDePartes$, podemos ver que realiza la porción de código interior a los dos bucles una cantidad de veces igual a la cantidad de combinaciones posibles con esos ítems. En la misma, se llaman a todas operaciones con complejidad $O(1)$, excepto la llamada a $pushBack$, que, si utilizamos un $vector$ de C++, tiene una complejidad de $O(1)$ amortizada. Por estas razones, la función tiene una complejidad perteneciente a $O(2^n)$, siendo $n$ la cantidad de ítems. Llamamos dos veces a esta función con una cantidad de ítems igual a la mitad de la cantidad original, lo que nos da una complejidad inicial de $O(2^{n/2})$, siendo $n$ la cantidad de ítems originales.\par
Siguiendo con el pseudocódigo, la función $sacarInservibles$ recorre todas las combinaciones o partes del conjunto de partes pasado como parámetro. Por cada una, otra vez, llama a todas operaciones con complejidad $O(1)$ u $O(1)$ amortizado, con lo que nos queda que la función tiene una complejidad de $O(n)$, siendo $n$ la cantidad de partes. Como la llamamos una sola vez con el conjunto de partes de una sola mitad de los ítems, nos suma $O(2^{n/2})$ a la complejidad inicial.\par
Llegando ya a la función combinar, vemos que recorre cada una de las $primerasPartes$, y realiza adentro una búsqueda binaria y otras operaciones con complejidad $O(1)$, amortizado o no. Realiza la búsqueda sobre las combinaciones de la segunda mitad. Como cada una de las mitades contiene como máximo $2^{n/2}$ combinaciones, la complejidad resultante es $O(2^{n/2} * \log{}2^{n/2}) = O(2^{n/2} * n/2)$.\par
Ahora sí calcularemos la complejidad del algoritmo en su totalidad. Primero, se parte el conjunto de ítems a la mitad, cosa que se puede hacer en $O(n)$ u $O(1)$, dependiendo de cómo se implemente. Luego, se llama dos veces a $conjuntoDePartes$, y cada una suma $O(2^{n/2})$ a la complejidad. $ordenarPartes$, si se utiliza, por ejemplo, merge-sort, puede tener una complejidad de $O(2^{n/2} * \log{}2^{n/2}) = O(2^{n/2} * n/2)$. Seguimos con $sacarInservibles$, la cual vimos que tiene una complejidad de $O(2^{n/2})$, y $combinar$, que vimos que nos suma $O(2^{n/2} * n/2)$. Por último, $encontrarMayorBeneficio$ simplemente recorre todas las posibles soluciones, que, como hay una posible solución por combinación en el primer conjunto de partes, nos suma solamente $O(2^{n/2})$.\par
Sumando todas estas complejidades diferentes llegamos a $O(n) + 2 * O(2^{n/2}) + O(2^{n/2} * n/2) + O(2^{n/2}) + O(2^{n/2} * n/2) + O(2^{n/2}) = O(2^{n/2} * n)$.

\section{Backtracking}
\subsection{Descripción}
En el algoritmo de Backtracking armaremos un árbol de decisiones, cada una especificando si incluimos un ítem en particular en la combinación actual o no. Haremos la decisión para el primer ítem, luego para el segundo ítem, y así. Cuando lleguemos a una hoja del árbol, compararemos el beneficio de los ítems que decidimos incluir en la combinación con el mejor beneficio encontrado hasta el momento, y nos quedaremos con el mejor.\par
A diferencia del algoritmo de Fuerza Bruta, para no probar con combinaciones de ítems que ya sabemos de antemano que no serán óptimas o que directamente no entrarán en la mochila, haremos podas de factibilidad y de optimalidad, es decir, cuando se cumplan algunas condiciones particulares, no seguiremos decidiendo en la rama en la que estamos, sino que pasaremos a una rama diferente.\par
La poda por factibilidad es simple: mientras vamos haciendo decisiones sobre los ítems, vamos sumando los tamaños de los que agregamos. Cuando el tamaño sumado sobrepasa la capacidad de la mochila, sabemos que esta rama no es factible, así que pasamos a la siguiente.\par
La poda por optimalidad, en cambio, es un poco más elaborada. Antes de comenzar a recorrer el árbol, ordenamos los ítems de mayor a menor según el valor que toma su $beneficio/tamano$; su ``ratio". Mientras recorremos el árbol, vamos sumando los beneficios de los ítems que agregamos a la combinación. Además, cada vez que debamos tomar a una decisión, nos fijamos si llenar la capacidad restante de la mochila con un ítem hipotético que tenga el mismo ratio que el ítem actual mejora el beneficio de la mejor solución encontrada hasta el momento. Si no lo mejora, ya sabemos que cualquier combinación de ítems siguientes no superará en beneficio a la solución que habíamos encontrado antes, y por lo tanto esta rama ya no nos sirve, lo que nos hace pasar a la siguiente.\par
Al finalizar, devolvemos el mayor beneficio que hayamos encontrado para una solución factible.

\subsection{}
%\end{framed}
\end{document}
