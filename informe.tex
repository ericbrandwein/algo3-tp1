\documentclass[10pt, a4paper]{article}
\usepackage[utf8]{inputenc}
% especifico márgenes manualmente
\usepackage[paper=a4paper]{geometry}
% codificación ISO-8859-1
%\usepackage[latin1]{inputenc}
% separación silábica en castellano
\usepackage[spanish]{babel}
\usepackage{algorithm}
\usepackage{algpseudocode}
%\usepackage{framed}
%\usepackage{array}
%\usepackage{tabular}

\title{Trabajo Pr\'actico 1}
\author{Eric Brandwein}
\date{Abril 2018}

\begin{document}

\maketitle

% compilar 2 veces para actualizar las referencias
\tableofcontents

\pagebreak
%\newpage


\section{Descripci\'on del problema}

%\begin{framed}
El problema a resolver en este informe será el ya conocido problema de la mochila, o "Knapsack problem", en inglés. Su enunciado dice así: \\
Dado un conjunto de $n$ ítems $S$, cada uno con un tamaño asociado $w_i$ y un beneficio asociado $p_i$, y una mochiula con una capacidad asociada $W$, encontrar el subconjunto de ítems de $S$ que maximice el beneficio total sin exceder la capacidad de la mochila. Es decir, encontrar $R \subseteq S$ tal que $\sum_{i \in R} p_i$ sea máxima y se cumpla $\sum_{i \in R} w_i \leq W$. Asumiremos que todos los valores mencionados son enteros no negativos.\par

Para entender mejor el problema, mostraremos un ejemplo: \par
Imaginemos que poseemos una mochila con capacidad 25, y que poseemos 5 ítems, cada uno con su tamaño y beneficio asociados de esta forma: \\
\begin{tabular}{c|c|c}
	ítem & tamaño & beneficio \\ \hline
	1 & 10 & 5 \\
	2 & 15 & 4 \\
	3 & 5 & 13 \\
	4 & 10 & 8 \\
	5 & 5 & 8
\end{tabular} \\
La combinación de ítems que maximizará el beneficio sin pasarse de la capacidad de la mochila será el conjunto $\{3, 4, 5\}$, que juntos suman un tamaño de $5 + 10 + 5 = 20$ y un beneficio de $13 + 8 + 8 = 29$. Cualquier otra combinación de los ítems que poseemos o no entrará en la mochila por tener un tamaño total mayor a la capacidad, o tendrá un beneficio total menor o igual al beneficio alcanzado con la solución dada. \par

Algorítmicamente, desarrollaremos cuatro maneras de llegar a la solución para cualquier conjunto de argumentos. Demostraremos la correctitud de cada una, y luego las compararemos tanto en términos de complejidad teórica como con comprobaciones empíricas. Las estrategias de programación que utilizaremos son:
\begin{itemize}
	\item Fuerza Bruta
	\item Meet in the Middle
	\item Backtracking
	\item Programación Dinámica
\end{itemize}

\section{Fuerza Bruta}
\subsection{Descripción}
Este algoritmo resuelve el problema comparando todas las combinaciones de ítems entre sí.
Las mismas se generan una tras otra. Cada vez que se genera una combinación de ítems, se calcula su beneficio y su tamaño total. Si el tamaño es mayor a la capacidad de la mochila, la combinación se descarta. Si no, se compara el beneficio total de la solución actual con el mayor beneficio alcanzado hasta el momento, y se mantiene el mayor beneficio entre los dos, para ser comparado más tarde con la próxima posible solución. Si para el momento de la comparación no se había encontrado todavía una combinación que entrase en la mochila, el mayor beneficio encontrado hasta el momento será igual a cero. Podemos comenzar asumiendo un beneficio cero porque sabemos que siempre existe por lo menos una combinación de ítems con este beneficio; particularmente, la combinación en la que no se pone ningún item en la mochila posee este beneficio total.\par
En el momento en el que ya se hubieron recorrido todas las combinaciones, el resultado será el mayor beneficio encontrado. \par

\subsection{Pseudocódigo}
\begin{algorithm}
\caption{Fuerza Bruta}
\begin{algorithmic}[1]
\Function{fuerzaBruta}{$capacidad, items$}
	\State $mayorBeneficio \gets 0$
	\State $combinacionActual \gets $\Call{primerCombinacion}{items}
	\While{\Call{combinacionValida?}{combinacionActual}}
		\State $tamanioActual \gets $\Call{tamanioDeCombinacion}{combinacion}
		\If{$tamanioActual \leq capacidad$}
			\State $beneficioActual \gets $\Call{beneficioDeCombinacion}{combinacionActual}
			\State $mayorBeneficio \gets max(beneficioActual, mayorBeneficio)$
		\EndIf

		\State $combinacionActual \gets $\Call{proximaCombinacion}{combinacionActual}
	\EndWhile
	\State \Return $mayorBeneficio$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Correctitud}
Sabemos que no hay un mejor resultado que el devuelto porque si existiese una combinación con beneficio mayor, la hubiésemos encontrado y guardado. Y sabemos que hay una combinación con ese beneficio porque solo guardamos el resultado si encontramos una combinación con ese beneficio. Por ende, el resultado devuelto es el correcto. \par

\section{Meet in the Middle}
\subsection{Descripción}
Este algoritmo toma ventaja de la búsqueda binaria para mejorar la complejidad del algoritmo de fuerza bruta. A grandes rasgos, el algoritmo sigue estos pasos: \\
\begin{enumerate}
	\item Divide al conjunto de ítems en dos mitades;
	\item Encuentra los tamaños y beneficios del conjunto de partes de cada una, sacando las partes que tengan un tamaño mayor a la capacidad de la mochila;
	\item Ordena las partes de la segunda mitad de menor a mayor en tamaño, y si hay dos partes con el mismo tamaño, las ordena de mayor a menor en beneficio;
	\item Saca las partes de la segunda mitad para las que exista otra parte con menor o igual tamaño e igual o mayor beneficio;
	\item Por cada parte del primer conjunto, se encuentra, con una búsqueda binaria por tamaño en el segundo conjunto, la parte que mejor llene la restante capacidad de la mochila. Es decir, la parte del segundo conjunto que tenga el mayor tamaño de las partes que, sumando el tamaño de la parte del primer conjunto, no sobrepasen la capacidad de la mochila;
	\item Se suman los beneficios de la parte encontrada con la parte actual del primer conjunto;
	\item Se encuentra el mayor beneficio entre las partes restantes, y se llega al resultado deseado.
\end{enumerate}


\subsection{Pseudocódigo}
\begin{algorithm}
\caption{Meet in the Middle}
\begin{algorithmic}[1]
\Function{fuerzaBruta}{$capacidad, items$}
	\State $mayorBeneficio \gets 0$
	\State $combinacionActual \gets $\Call{primerCombinacion}{items}
	\While{\Call{combinacionValida?}{combinacionActual}}
		\State $tamanioActual \gets $\Call{tamanioDeCombinacion}{combinacion}
		\If{$tamanioActual \leq capacidad$}
			\State $beneficioActual \gets $\Call{beneficioDeCombinacion}{combinacionActual}
			\State $mayorBeneficio \gets max(beneficioActual, mayorBeneficio)$
		\EndIf

		\State $combinacionActual \gets $\Call{proximaCombinacion}{combinacionActual}
	\EndWhile
	\State \Return $mayorBeneficio$
\EndFunction
\end{algorithmic}
\end{algorithm}



%\end{framed}
\end{document}
